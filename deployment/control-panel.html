<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Noona Deployment Console</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      color-scheme: dark;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0f172a;
      color: #e2e8f0;
    }

    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header {
      padding: 1.5rem 2rem 1rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(12px);
    }

    header h1 {
      margin: 0 0 0.25rem;
      font-size: 1.5rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    header p {
      margin: 0;
      color: rgba(226, 232, 240, 0.75);
      max-width: 60ch;
    }

    main {
      flex: 1;
      padding: 2rem;
      display: grid;
      gap: 1.5rem;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      align-content: start;
    }

    section {
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 16px;
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      box-shadow: 0 24px 64px rgba(15, 23, 42, 0.45);
    }

    section h2 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    fieldset {
      border: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: rgba(226, 232, 240, 0.65);
    }

    .help-text {
      display: block;
      margin-top: 0.35rem;
      font-size: 0.7rem;
      text-transform: none;
      letter-spacing: 0;
      color: rgba(226, 232, 240, 0.6);
    }

    input, select, textarea {
      padding: 0.5rem 0.75rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.6);
      color: inherit;
      font: inherit;
      resize: vertical;
    }

    button {
      padding: 0.6rem 1rem;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, #6366f1, #7c3aed);
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(99, 102, 241, 0.35);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }

    .stream-panel {
      grid-column: 1 / -1;
      min-height: 200px;
    }

    #stream-output {
      background: rgba(2, 6, 23, 0.85);
      border-radius: 12px;
      padding: 1rem;
      font-family: "Fira Code", "SFMono-Regular", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.85rem;
      height: 280px;
      overflow-y: auto;
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    .status-ok { color: #34d399; }
    .status-info { color: #93c5fd; }
    .status-error { color: #f87171; }
    .status-warn { color: #fbbf24; }

    .inline-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .inline-group > * {
      flex: 1 1 140px;
    }

    .is-hidden {
      display: none !important;
    }

    .log-entry {
      display: flex;
      gap: 0.65rem;
      align-items: flex-start;
      margin-bottom: 0.4rem;
      line-height: 1.4;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .log-entry:last-child {
      margin-bottom: 0;
    }

    .log-context {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(148, 163, 184, 0.75);
      flex: 0 0 auto;
    }

    .log-message {
      flex: 1 1 auto;
    }

    .log-entry pre {
      margin: 0;
      border-radius: 0.75rem;
      padding: 0.65rem 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.65);
    }
  </style>
</head>
<body>
  <header>
    <h1>Warden Deployment Console</h1>
    <p>Invoke Docker orchestration commands directly from your browser. Streaming responses mirror the CLI&apos;s NDJSON feed.</p>
  </header>
  <main>
    <section>
      <h2>Services</h2>
      <div class="controls">
        <button type="button" data-action="list-services">Refresh status</button>
        <button type="button" data-action="load-settings">Load settings</button>
      </div>
      <pre id="services-output" aria-live="polite">Click “Refresh status” to load deployment information.</pre>
    </section>

    <section>
      <h2>Build</h2>
      <fieldset>
        <div class="inline-group">
          <label>
            Services to build
            <select id="build-services" multiple size="6" aria-describedby="build-services-help"></select>
            <span id="build-services-help" class="help-text">Select one or more services, or choose “All services” to build the entire stack.</span>
          </label>
          <label>
            Concurrency override
            <input id="build-concurrency" placeholder="{""workers"":2}" autocomplete="off" />
          </label>
        </div>
        <label>
          <input type="checkbox" id="build-nocache" /> Use --no-cache
        </label>
      </fieldset>
      <button type="button" data-action="build">Start build</button>
    </section>

    <section>
      <h2>Push / Pull</h2>
      <fieldset>
        <label>
          Services
          <select id="registry-services" multiple size="6" aria-describedby="registry-services-help"></select>
          <span id="registry-services-help" class="help-text">Select one or more services, or choose “All services” to operate on every image.</span>
        </label>
      </fieldset>
      <div class="controls">
        <button type="button" data-action="push">Push images</button>
        <button type="button" data-action="pull">Pull images</button>
      </div>
    </section>

    <section>
      <h2>Start / Stop</h2>
      <fieldset>
        <div class="inline-group">
          <label>
            Services
            <select id="start-services" multiple size="6" aria-describedby="start-services-help"></select>
            <span id="start-services-help" class="help-text">Select one or more services to launch, or choose “All services”.</span>
          </label>
          <label>
            Debug level
            <select id="start-debug">
              <option value="auto">auto</option>
              <option value="info">info</option>
              <option value="debug">debug</option>
              <option value="super">super</option>
            </select>
          </label>
          <label>
            Boot mode
            <select id="start-boot">
              <option value="standard">standard</option>
              <option value="super">super</option>
            </select>
          </label>
        </div>
        <label id="start-docker-socket-field" class="is-hidden">
          <input type="checkbox" id="start-docker-socket" checked /> Bind host Docker socket
          <span class="help-text">Expose the host Docker socket when launching Warden. Override the socket path from the Settings panel if needed.</span>
        </label>
      </fieldset>
      <div class="controls">
        <button type="button" data-action="start">Start services</button>
        <button type="button" data-action="stop">Stop all</button>
      </div>
    </section>

    <section>
      <h2>Cleanup</h2>
      <fieldset>
        <label>
          Services
          <select id="clean-services" multiple size="6" aria-describedby="clean-services-help"></select>
          <span id="clean-services-help" class="help-text">Select specific services or choose “All services” to remove every resource.</span>
        </label>
        <label>
          <input type="checkbox" id="delete-confirm" /> Confirm full Docker prune
        </label>
      </fieldset>
      <div class="controls">
        <button type="button" data-action="clean">Remove selected resources</button>
        <button type="button" data-action="delete">Delete all Noona Docker resources</button>
      </div>
    </section>

    <section>
      <h2>Settings</h2>
      <fieldset>
        <label>
          Host Docker socket override
          <input id="settings-host-socket" placeholder="/var/run/docker.sock" autocomplete="off" />
          <span class="help-text">Optional host socket path to bind when starting Warden. Leave blank to auto-detect.</span>
        </label>
        <label>
          Raw JSON payload
          <textarea id="settings-json" rows="6" placeholder='{"defaults":{"debugLevel":"debug"}}'></textarea>
        </label>
      </fieldset>
      <button type="button" data-action="update-settings">Update settings</button>
      <pre id="settings-output" aria-live="polite">Settings output will appear here.</pre>
    </section>

    <section class="stream-panel">
      <h2>Streaming Output</h2>
      <div id="stream-output" aria-live="polite"></div>
    </section>
  </main>
  <script>
    const servicesOutput = document.getElementById('services-output');
    const streamOutput = document.getElementById('stream-output');
    const settingsOutput = document.getElementById('settings-output');
    const buildServicesSelect = document.getElementById('build-services');
    const registryServicesSelect = document.getElementById('registry-services');
    const startServicesSelect = document.getElementById('start-services');
    const cleanServicesSelect = document.getElementById('clean-services');
    const startDockerSocketCheckbox = document.getElementById('start-docker-socket');
    const startDockerSocketField = document.getElementById('start-docker-socket-field');
    const settingsHostSocketInput = document.getElementById('settings-host-socket');

    const LOG_LIMIT = 500;
    const SERVICES_ENDPOINT = '/api/services?includeStopped=true';
    const ALL_SERVICES_OPTION_VALUE = 'all';
    const serviceSelectControllers = [];

    const formatJSON = (value) => {
      try {
        return JSON.stringify(value, null, 2);
      } catch (error) {
        return String(value);
      }
    };

    const formatTable = (rows = [], columns) => {
      if (!Array.isArray(rows) || rows.length === 0) {
        return '—';
      }
      const resolvedColumns = Array.isArray(columns) && columns.length
        ? columns
        : Array.from(new Set(rows.flatMap((row) => Object.keys(row || {}))));
      const normalized = rows.map((row) => {
        const source = row && typeof row === 'object' ? row : {};
        return resolvedColumns.map((column) => String(source[column] ?? ''));
      });
      const widths = resolvedColumns.map((column, columnIndex) => {
        return Math.max(
          column.length,
          ...normalized.map((row) => row[columnIndex].length)
        );
      });
      const header = resolvedColumns
        .map((column, index) => column.padEnd(widths[index]))
        .join('  ');
      const separator = widths.map((width) => '─'.repeat(width)).join('  ');
      const body = normalized
        .map((row) => row.map((value, index) => value.padEnd(widths[index])).join('  '))
        .join('\n');
      return `${header}\n${separator}\n${body}`;
    };

    const formatProgressEvent = (event = {}) => {
      const { type, service, step, status, message } = event;
      const parts = [];
      if (type) parts.push(type);
      if (service) parts.push(`service: ${service}`);
      if (step) parts.push(`step: ${step}`);
      if (status) parts.push(`status: ${status}`);
      if (message) parts.push(message);
      if (parts.length === 0) {
        return JSON.stringify(event);
      }
      return parts.join(' • ');
    };

    const HOST_SERVICE_URL_PATTERN = /host_service_url="?([^"\s]+)"?/i;

    const toLocalhostUrl = (value) => {
      if (!value) return null;
      const trimmed = value.trim();
      const hasProtocol = /^[a-zA-Z][a-zA-Z\d+\-.]*:/.test(trimmed);
      const candidate = hasProtocol ? trimmed : `http://${trimmed.replace(/^\/+/, '')}`;
      try {
        const url = new URL(candidate);
        if (!url.hostname) return null;
        if (url.protocol !== 'http:' && url.protocol !== 'https:') {
          return null;
        }
        url.hostname = 'localhost';
        return url.toString();
      } catch (error) {
        return null;
      }
    };

    const renderContainerLogEvent = ({ service, line } = {}) => {
      const fragment = document.createDocumentFragment();
      const prefix = service ? `${service}: ` : '';
      if (prefix) {
        fragment.append(document.createTextNode(prefix));
      }

      const text = typeof line === 'string' ? line : line ?? '';
      const match = typeof text === 'string' ? text.match(HOST_SERVICE_URL_PATTERN) : null;

      if (!match) {
        fragment.append(document.createTextNode(text));
        return fragment;
      }

      const [fullMatch, rawUrl] = match;
      const before = text.slice(0, match.index);
      const after = text.slice(match.index + fullMatch.length);

      if (before) {
        fragment.append(document.createTextNode(before));
      }

      const normalizedUrl = toLocalhostUrl(rawUrl);
      const href = normalizedUrl || rawUrl;
      const anchor = document.createElement('a');
      anchor.href = href;
      anchor.textContent = normalizedUrl || rawUrl;
      anchor.target = '_blank';
      anchor.rel = 'noreferrer noopener';
      fragment.append(anchor);

      if (after) {
        fragment.append(document.createTextNode(after));
      }

      return fragment;
    };

    const appendStreamLine = (payload = {}) => {
      const entry = document.createElement('div');
      entry.classList.add('log-entry');
      const context = document.createElement('span');
      context.classList.add('log-context');
      context.textContent = `[${payload.action ?? 'event'}]`;
      entry.appendChild(context);

      const messageNode = document.createElement(payload.type === 'table' ? 'pre' : 'span');
      messageNode.classList.add('log-message');

      if (payload.type === 'log') {
        const level = payload.level || 'info';
        const levelClass =
          level === 'success'
            ? 'status-ok'
            : ['warn', 'error', 'info'].includes(level)
              ? `status-${level}`
              : 'status-info';
        entry.classList.add(levelClass);
        messageNode.textContent = payload.message ?? '';
      } else if (payload.type === 'error') {
        entry.classList.add('status-error');
        messageNode.textContent = payload.message ?? JSON.stringify(payload);
      } else if (payload.type === 'container-log') {
        messageNode.append(renderContainerLogEvent(payload.event || {}));
      } else if (payload.type === 'progress') {
        messageNode.textContent = formatProgressEvent(payload.event);
      } else if (payload.type === 'table') {
        messageNode.textContent = formatTable(payload.data, payload.columns);
      } else if (typeof payload.message === 'string') {
        messageNode.textContent = payload.message;
      } else {
        messageNode.textContent = JSON.stringify(payload);
      }

      entry.appendChild(messageNode);

      if (streamOutput.children.length >= LOG_LIMIT) {
        streamOutput.removeChild(streamOutput.firstChild);
      }

      streamOutput.appendChild(entry);
      streamOutput.scrollTop = streamOutput.scrollHeight;
    };

    const clearStream = (label) => {
      streamOutput.textContent = '';
      appendStreamLine({ action: label, type: 'start', message: 'Request dispatched' });
    };

    const extractServiceNames = (services) => {
      if (!Array.isArray(services)) return [];
      const seen = new Set();
      const names = [];
      for (const service of services) {
        const candidate =
          typeof service === 'string'
            ? service
            : typeof service?.name === 'string'
              ? service.name
              : typeof service?.id === 'string'
                ? service.id
                : undefined;
        if (!candidate) continue;
        const normalized = candidate.trim();
        if (!normalized || seen.has(normalized)) continue;
        seen.add(normalized);
        names.push(normalized);
      }
      return names;
    };

    const createServiceSelectController = (select, { includeAllOption = false, defaultToAll = false } = {}) => {
      if (!select) return null;
      let selectionSnapshot = new Set();

      const updateSnapshot = () => {
        selectionSnapshot = new Set(
          Array.from(select.selectedOptions || []).map((option) => option.value)
        );
      };

      const applyOptions = (serviceNames = []) => {
        const previousSelection = new Set(selectionSnapshot);
        const shouldSelectAll = includeAllOption && (
          previousSelection.has(ALL_SERVICES_OPTION_VALUE) ||
          (previousSelection.size === 0 && defaultToAll)
        );

        select.innerHTML = '';

        if (includeAllOption) {
          const allOption = document.createElement('option');
          allOption.value = ALL_SERVICES_OPTION_VALUE;
          allOption.textContent = 'All services';
          if (shouldSelectAll) {
            allOption.selected = true;
          }
          select.appendChild(allOption);
        }

        for (const name of serviceNames) {
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          if (previousSelection.has(name)) {
            option.selected = true;
          }
          select.appendChild(option);
        }

        if (includeAllOption && select.selectedOptions.length === 0 && shouldSelectAll) {
          const allOption = select.querySelector(`option[value="${ALL_SERVICES_OPTION_VALUE}"]`);
          if (allOption) {
            allOption.selected = true;
          }
        }

        updateSnapshot();
      };

      const handleChange = () => {
        if (!includeAllOption) {
          updateSnapshot();
          return;
        }

        const previousSelection = new Set(selectionSnapshot);
        const currentValues = Array.from(select.selectedOptions || []).map((option) => option.value);
        const currentSet = new Set(currentValues);
        const added = currentValues.filter((value) => !previousSelection.has(value));
        const removed = [...previousSelection].filter((value) => !currentSet.has(value));
        const lastChanged = added.length
          ? added[added.length - 1]
          : (removed.length ? removed[removed.length - 1] : null);

        if (currentSet.has(ALL_SERVICES_OPTION_VALUE) && currentSet.size > 1) {
          if (lastChanged === ALL_SERVICES_OPTION_VALUE) {
            for (const option of select.options) {
              option.selected = option.value === ALL_SERVICES_OPTION_VALUE;
            }
          } else {
            for (const option of select.options) {
              if (option.value === ALL_SERVICES_OPTION_VALUE) {
                option.selected = false;
                break;
              }
            }
          }
        }

        updateSnapshot();
      };

      select.addEventListener('change', handleChange);

      return {
        element: select,
        applyOptions,
        getSelection: () => {
          const values = Array.from(select.selectedOptions || []).map((option) => option.value);
          if (includeAllOption && values.includes(ALL_SERVICES_OPTION_VALUE)) {
            return ALL_SERVICES_OPTION_VALUE;
          }
          return values;
        },
        isSelected: (value) => {
          const values = Array.from(select.selectedOptions || []).map((option) => option.value);
          if (includeAllOption && values.includes(ALL_SERVICES_OPTION_VALUE)) {
            return true;
          }
          return values.includes(value);
        }
      };
    };

    const registerServiceSelect = (select, options) => {
      const controller = createServiceSelectController(select, options);
      if (controller) {
        serviceSelectControllers.push(controller);
      }
      return controller;
    };

    const buildServicesController = registerServiceSelect(buildServicesSelect, { includeAllOption: true, defaultToAll: true });
    const registryServicesController = registerServiceSelect(registryServicesSelect, { includeAllOption: true });
    const startServicesController = registerServiceSelect(startServicesSelect, { includeAllOption: true });
    const cleanServicesController = registerServiceSelect(cleanServicesSelect, { includeAllOption: true });

    const getSelectionForPayload = (controller) => controller?.getSelection?.() ?? [];

    const resolveServicesForPayload = (selection) => {
      if (!selection) return null;
      if (selection === ALL_SERVICES_OPTION_VALUE) {
        return 'all';
      }
      if (Array.isArray(selection) && selection.length) {
        return selection;
      }
      return null;
    };

    const isWardenSelected = () => {
      if (!startServicesController) return false;
      const selection = startServicesController.getSelection?.();
      if (!selection) return false;
      if (selection === ALL_SERVICES_OPTION_VALUE) {
        return true;
      }
      return Array.isArray(selection) && selection.includes('warden');
    };

    const updateStartDockerSocketVisibility = () => {
      if (!startDockerSocketField || !startDockerSocketCheckbox) return;
      const show = isWardenSelected();
      startDockerSocketField.classList.toggle('is-hidden', !show);
      startDockerSocketCheckbox.disabled = !show;
    };

    if (startServicesController?.element) {
      startServicesController.element.addEventListener('change', updateStartDockerSocketVisibility);
    }

    const populateServiceSelects = (serviceNames = []) => {
      for (const controller of serviceSelectControllers) {
        controller?.applyOptions?.(serviceNames);
      }
      updateStartDockerSocketVisibility();
    };

    const fetchServiceCatalog = async () => {
      try {
        const response = await fetch(SERVICES_ENDPOINT);
        if (!response.ok && response.status !== 207) {
          return;
        }
        const payload = await response.json();
        populateServiceSelects(extractServiceNames(payload?.services));
      } catch (error) {
        console.warn('Failed to load service catalog', error);
      }
    };

    const safeParseJSON = (value) => {
      if (!value.trim()) return null;
      try {
        return JSON.parse(value);
      } catch (error) {
        throw new Error('Invalid JSON payload: ' + error.message);
      }
    };

    const readNDJSON = async (response, action) => {
      const reader = response.body?.getReader();
      if (!reader) {
        appendStreamLine({ action, type: 'error', message: 'Streaming unsupported in this browser.' });
        return;
      }

      const decoder = new TextDecoder();
      let buffer = '';
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop();
        for (const line of lines) {
          if (!line.trim()) continue;
          try {
            const payload = JSON.parse(line);
            appendStreamLine(payload);
          } catch (error) {
            appendStreamLine({ action, type: 'error', message: 'Malformed stream payload', raw: line });
          }
        }
      }
      if (buffer.trim()) {
        try {
          appendStreamLine(JSON.parse(buffer));
        } catch (error) {
          appendStreamLine({ action, type: 'error', message: 'Malformed stream payload', raw: buffer });
        }
      }
    };

    const invokeStreamEndpoint = async (action, url, payload) => {
      clearStream(action);
      let response;
      try {
        response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload ?? {})
        });
      } catch (error) {
        appendStreamLine({ action, type: 'error', message: error.message });
        return;
      }
      if (!response.ok && response.status !== 207) {
        appendStreamLine({ action, type: 'error', message: `Request failed: ${response.status}` });
        return;
      }
      await readNDJSON(response, action);
    };

    const actions = {
      'list-services': async () => {
        let response;
        try {
          response = await fetch(SERVICES_ENDPOINT);
        } catch (error) {
          servicesOutput.textContent = `Failed to load services (${error.message})`;
          return;
        }
        if (!response.ok && response.status !== 207) {
          servicesOutput.textContent = `Failed to load services (${response.status})`;
          return;
        }
        const payload = await response.json();
        populateServiceSelects(extractServiceNames(payload?.services));
        const statusLabel = payload.ok ? 'status-ok' : 'status-warn';
        servicesOutput.innerHTML = '';
        const statusNode = document.createElement('span');
        statusNode.className = statusLabel;
        statusNode.textContent = payload.ok ? 'Healthy' : 'Partial';
        servicesOutput.appendChild(statusNode);
        servicesOutput.appendChild(document.createTextNode(`\n${formatJSON(payload)}`));
      },
      'load-settings': async () => {
        const response = await fetch('/api/settings');
        if (!response.ok) {
          settingsOutput.textContent = `Failed to load settings (${response.status})`;
          return;
        }
        const payload = await response.json();
        settingsOutput.textContent = formatJSON(payload);
        document.getElementById('settings-json').value = JSON.stringify(payload, null, 2);
        if (settingsHostSocketInput) {
          const value = Object.prototype.hasOwnProperty.call(payload || {}, 'hostDockerSocketOverride')
            ? payload.hostDockerSocketOverride
            : '';
          settingsHostSocketInput.value = value ?? '';
        }
      },
      build: async () => {
        const selection = getSelectionForPayload(buildServicesController);
        const services = resolveServicesForPayload(selection);
        const concurrency = document.getElementById('build-concurrency').value;
        const payload = {
          useNoCache: document.getElementById('build-nocache').checked
        };
        if (services) {
          payload.services = services;
        }
        if (concurrency.trim()) {
          payload.concurrency = safeParseJSON(concurrency);
        }
        await invokeStreamEndpoint('build', '/api/build', payload);
      },
      push: async () => {
        const selection = getSelectionForPayload(registryServicesController);
        const services = resolveServicesForPayload(selection);
        const payload = {};
        if (services) {
          payload.services = services;
        }
        await invokeStreamEndpoint('push', '/api/push', payload);
      },
      pull: async () => {
        const selection = getSelectionForPayload(registryServicesController);
        const services = resolveServicesForPayload(selection);
        const payload = {};
        if (services) {
          payload.services = services;
        }
        await invokeStreamEndpoint('pull', '/api/pull', payload);
      },
      start: async () => {
        const selection = getSelectionForPayload(startServicesController);
        const services = resolveServicesForPayload(selection);
        const wardenSelected = startServicesController?.isSelected?.('warden') ?? false;
        const shouldBindHostDockerSocket = Boolean(wardenSelected && startDockerSocketCheckbox?.checked);
        const payload = {
          debugLevel: document.getElementById('start-debug').value || undefined,
          bootMode: document.getElementById('start-boot').value || undefined,
          useHostDockerSocket: shouldBindHostDockerSocket
        };
        if (services) {
          payload.services = services;
        }
        if (shouldBindHostDockerSocket && settingsHostSocketInput) {
          const overrideValue = settingsHostSocketInput.value.trim();
          if (overrideValue) {
            payload.hostDockerSocketOverride = overrideValue;
          }
        }
        await invokeStreamEndpoint('start', '/api/start', payload);
      },
      stop: async () => {
        await invokeStreamEndpoint('stop', '/api/stop');
      },
      clean: async () => {
        const selection = getSelectionForPayload(cleanServicesController);
        const services = resolveServicesForPayload(selection);
        const payload = {};
        if (services) {
          payload.services = services;
        }
        await invokeStreamEndpoint('clean', '/api/clean', payload);
      },
      delete: async () => {
        const confirmDelete = document.getElementById('delete-confirm').checked;
        if (!confirmDelete) {
          alert('Please enable the confirmation checkbox before deleting resources.');
          return;
        }
        await invokeStreamEndpoint('delete', '/api/delete', { confirm: true });
      },
      'update-settings': async () => {
        try {
          const parsedPayload = safeParseJSON(document.getElementById('settings-json').value || '{}');
          const payload = (parsedPayload && typeof parsedPayload === 'object') ? parsedPayload : {};
          if (payload && typeof payload === 'object' && payload.defaults && Object.prototype.hasOwnProperty.call(payload.defaults, 'hostDockerSocketOverride')) {
            delete payload.defaults.hostDockerSocketOverride;
          }
          if (settingsHostSocketInput) {
            const overrideValue = settingsHostSocketInput.value.trim();
            payload.hostDockerSocketOverride = overrideValue ? overrideValue : null;
          }
          const response = await fetch('/api/settings', {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload || {})
          });
          if (!response.ok) {
            settingsOutput.textContent = `Failed to update settings (${response.status})`;
            return;
          }
          const body = await response.json();
          settingsOutput.textContent = formatJSON(body);
          if (settingsHostSocketInput) {
            const value = Object.prototype.hasOwnProperty.call(body || {}, 'hostDockerSocketOverride')
              ? body.hostDockerSocketOverride
              : '';
            settingsHostSocketInput.value = value ?? '';
          }
          document.getElementById('settings-json').value = JSON.stringify(body, null, 2);
        } catch (error) {
          settingsOutput.textContent = error.message;
        }
      }
    };

    document.body.addEventListener('click', async (event) => {
      const action = event.target?.dataset?.action;
      if (!action || !actions[action]) return;
      event.preventDefault();
      try {
        await actions[action]();
      } catch (error) {
        appendStreamLine({ action, type: 'error', message: error.message });
      }
    });

    populateServiceSelects();
    fetchServiceCatalog();
  </script>
</body>
</html>
