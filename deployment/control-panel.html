<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Noona Deployment Console</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root {
      color-scheme: dark;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0f172a;
      color: #e2e8f0;
    }

    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }

    header {
      padding: 1.5rem 2rem 1rem;
      border-bottom: 1px solid rgba(148, 163, 184, 0.2);
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(12px);
    }

    header h1 {
      margin: 0 0 0.25rem;
      font-size: 1.5rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    header p {
      margin: 0;
      color: rgba(226, 232, 240, 0.75);
      max-width: 60ch;
    }

    main {
      flex: 1;
      padding: 2rem;
      display: grid;
      gap: 1.5rem;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      align-content: start;
    }

    section {
      background: rgba(15, 23, 42, 0.9);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 16px;
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      box-shadow: 0 24px 64px rgba(15, 23, 42, 0.45);
    }

    section h2 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    fieldset {
      border: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: rgba(226, 232, 240, 0.65);
    }

    .help-text {
      display: block;
      margin-top: 0.35rem;
      font-size: 0.7rem;
      text-transform: none;
      letter-spacing: 0;
      color: rgba(226, 232, 240, 0.6);
    }

    input, select, textarea {
      padding: 0.5rem 0.75rem;
      border-radius: 10px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(15, 23, 42, 0.6);
      color: inherit;
      font: inherit;
      resize: vertical;
    }

    [hidden] {
      display: none !important;
    }

    button {
      padding: 0.6rem 1rem;
      border-radius: 999px;
      border: none;
      background: linear-gradient(135deg, #6366f1, #7c3aed);
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 24px rgba(99, 102, 241, 0.35);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }

    .stream-panel {
      grid-column: 1 / -1;
      min-height: 200px;
    }

    #stream-output {
      background: rgba(2, 6, 23, 0.85);
      border-radius: 12px;
      padding: 1rem;
      font-family: "Fira Code", "SFMono-Regular", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.85rem;
      height: 280px;
      overflow-y: auto;
      border: 1px solid rgba(148, 163, 184, 0.35);
    }

    .status-ok { color: #34d399; }
    .status-info { color: #93c5fd; }
    .status-error { color: #f87171; }
    .status-warn { color: #fbbf24; }

    .inline-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .inline-group > * {
      flex: 1 1 140px;
    }

    .log-entry {
      display: flex;
      gap: 0.65rem;
      align-items: flex-start;
      margin-bottom: 0.4rem;
      line-height: 1.4;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .log-entry:last-child {
      margin-bottom: 0;
    }

    .log-context {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(148, 163, 184, 0.75);
      flex: 0 0 auto;
    }

    .log-message {
      flex: 1 1 auto;
    }

    .log-entry pre {
      margin: 0;
      border-radius: 0.75rem;
      padding: 0.65rem 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.25);
      background: rgba(15, 23, 42, 0.65);
    }
  </style>
</head>
<body>
  <header>
    <h1>Warden Deployment Console</h1>
    <p>Invoke Docker orchestration commands directly from your browser. Streaming responses mirror the CLI&apos;s NDJSON feed.</p>
  </header>
  <main>
    <section>
      <h2>Services</h2>
      <div class="controls">
        <button type="button" data-action="list-services">Refresh status</button>
        <button type="button" data-action="load-settings">Load settings</button>
      </div>
      <pre id="services-output" aria-live="polite">Click “Refresh status” to load deployment information.</pre>
    </section>

    <section>
      <h2>Build</h2>
      <fieldset>
        <div class="inline-group">
          <label>
            Services to build
            <select id="build-services" multiple size="6" aria-describedby="build-services-help"></select>
            <span id="build-services-help" class="help-text">Select one or more services, or choose “All services” to build the entire stack.</span>
          </label>
          <label>
            Concurrency override
            <input id="build-concurrency" placeholder="{""workers"":2}" autocomplete="off" />
          </label>
        </div>
        <label>
          <input type="checkbox" id="build-nocache" /> Use --no-cache
        </label>
      </fieldset>
      <button type="button" data-action="build">Start build</button>
    </section>

    <section>
      <h2>Push / Pull</h2>
      <fieldset>
        <label>
          Services
          <select id="registry-services" multiple size="6" aria-describedby="registry-services-help"></select>
          <span id="registry-services-help" class="help-text">Select one or more services, or choose “All services”.</span>
        </label>
      </fieldset>
      <div class="controls">
        <button type="button" data-action="push">Push images</button>
        <button type="button" data-action="pull">Pull images</button>
      </div>
    </section>

    <section>
      <h2>Start / Stop</h2>
      <fieldset>
        <div class="inline-group">
          <label>
            Services
            <select id="start-services" multiple size="6" aria-describedby="start-services-help"></select>
            <span id="start-services-help" class="help-text">Select one or more services, or choose “All services”.</span>
          </label>
          <label>
            Debug level
            <select id="start-debug">
              <option value="auto">auto</option>
              <option value="info">info</option>
              <option value="debug">debug</option>
              <option value="super">super</option>
            </select>
          </label>
          <label>
            Boot mode
            <select id="start-boot">
              <option value="standard">standard</option>
              <option value="super">super</option>
            </select>
          </label>
        </div>
        <label data-role="warden-socket-toggle" hidden>
          <input type="checkbox" id="start-use-host-socket" /> Use configured host Docker socket override
          <span class="help-text">Mounts the override path defined in Settings when starting Warden.</span>
        </label>
      </fieldset>
      <div class="controls">
        <button type="button" data-action="start">Start services</button>
        <button type="button" data-action="stop">Stop all</button>
      </div>
    </section>

    <section>
      <h2>Cleanup</h2>
      <fieldset>
        <label>
          Services
          <select id="clean-services" multiple size="6" aria-describedby="clean-services-help"></select>
          <span id="clean-services-help" class="help-text">Select one or more services, or choose “All services”.</span>
        </label>
        <label>
          <input type="checkbox" id="delete-confirm" /> Confirm full Docker prune
        </label>
      </fieldset>
      <div class="controls">
        <button type="button" data-action="clean">Remove selected resources</button>
        <button type="button" data-action="delete">Delete all Noona Docker resources</button>
      </div>
    </section>

    <section>
      <h2>Settings</h2>
      <fieldset>
        <label>
          Host Docker socket override
          <input id="settings-host-socket" placeholder="/var/run/docker.sock" autocomplete="off" />
          <span class="help-text">Optional host socket path to bind when starting Warden. Leave blank to auto-detect.</span>
        </label>
        <label>
          Raw JSON payload
          <textarea id="settings-json" rows="6" placeholder='{"defaults":{"debugLevel":"debug"}}'></textarea>
        </label>
      </fieldset>
      <button type="button" data-action="update-settings">Update settings</button>
      <pre id="settings-output" aria-live="polite">Settings output will appear here.</pre>
    </section>

    <section class="stream-panel">
      <h2>Streaming Output</h2>
      <div id="stream-output" aria-live="polite"></div>
    </section>
  </main>
  <script>
    const servicesOutput = document.getElementById('services-output');
    const streamOutput = document.getElementById('stream-output');
    const settingsOutput = document.getElementById('settings-output');
    const buildServicesSelect = document.getElementById('build-services');
    const startServicesSelect = document.getElementById('start-services');
    const registryServicesSelect = document.getElementById('registry-services');
    const cleanServicesSelect = document.getElementById('clean-services');
    const settingsHostSocketInput = document.getElementById('settings-host-socket');
    const startDockerSocketContainer = document.querySelector('[data-role="warden-socket-toggle"]');
    const startDockerSocketCheckbox = document.getElementById('start-use-host-socket');

    const LOG_LIMIT = 500;
    const SERVICES_ENDPOINT = '/api/services?includeStopped=true';
    const ALL_SERVICES_OPTION_VALUE = 'all';
    let startDockerSocketCheckboxTouched = false;

    const updateStartDockerSocketVisibility = (selection = new Set()) => {
      if (!startDockerSocketContainer) return;
      const selectionSet = selection instanceof Set ? selection : new Set(selection);
      const includesWarden = selectionSet.has('warden') || selectionSet.has(ALL_SERVICES_OPTION_VALUE);
      if (includesWarden) {
        startDockerSocketContainer.hidden = false;
        const hasOverride = Boolean(settingsHostSocketInput?.value.trim());
        if (startDockerSocketCheckbox) {
          startDockerSocketCheckbox.disabled = !hasOverride;
          if (!hasOverride) {
            startDockerSocketCheckbox.checked = false;
            startDockerSocketCheckboxTouched = false;
          } else if (!startDockerSocketCheckboxTouched) {
            startDockerSocketCheckbox.checked = true;
          }
        }
      } else {
        startDockerSocketContainer.hidden = true;
        if (startDockerSocketCheckbox) {
          startDockerSocketCheckbox.checked = false;
        }
        startDockerSocketCheckboxTouched = false;
      }
    };

    const createServiceSelectController = (select, { includeAllOption = false, defaultToAll = false } = {}) => {
      if (!select) return null;
      let snapshot = new Set();

      const readValuesFromDom = () =>
        Array.from(select.selectedOptions || []).map((option) => option.value).filter(Boolean);

      const applySelection = (selectionSet) => {
        for (const option of select.options) {
          option.selected = selectionSet.has(option.value);
        }
      };

      const controller = {
        element: select,
        includeAllOption,
        populate(serviceNames = []) {
          const previous = new Set(snapshot);
          const desired = previous.size
            ? previous
            : defaultToAll && includeAllOption
              ? new Set([ALL_SERVICES_OPTION_VALUE])
              : new Set();
          select.innerHTML = '';

          if (includeAllOption) {
            const allOption = document.createElement('option');
            allOption.value = ALL_SERVICES_OPTION_VALUE;
            allOption.textContent = 'All services';
            select.appendChild(allOption);
          }

          for (const name of serviceNames) {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            select.appendChild(option);
          }

          const valid = new Set(
            [...desired].filter((value) => value === ALL_SERVICES_OPTION_VALUE || serviceNames.includes(value))
          );

          if (valid.size === 0 && defaultToAll && includeAllOption) {
            valid.add(ALL_SERVICES_OPTION_VALUE);
          }

          snapshot = valid;
          applySelection(snapshot);
          controller.onChange?.(new Set(snapshot));
        },
        read() {
          if (!snapshot.size) return [];
          if (includeAllOption && snapshot.has(ALL_SERVICES_OPTION_VALUE)) {
            return ALL_SERVICES_OPTION_VALUE;
          }
          return Array.from(snapshot);
        },
        get snapshot() {
          return new Set(snapshot);
        },
        onChange: null
      };

      select.addEventListener('change', () => {
        const previous = new Set(snapshot);
        const currentValues = readValuesFromDom();
        const currentSet = new Set(currentValues);
        const added = currentValues.filter((value) => !previous.has(value));
        const removed = [...previous].filter((value) => !currentSet.has(value));
        const lastChanged = added.length
          ? added[added.length - 1]
          : removed.length
            ? removed[removed.length - 1]
            : null;

        if (includeAllOption && currentSet.has(ALL_SERVICES_OPTION_VALUE) && currentSet.size > 1) {
          if (lastChanged === ALL_SERVICES_OPTION_VALUE) {
            snapshot = new Set([ALL_SERVICES_OPTION_VALUE]);
          } else {
            currentSet.delete(ALL_SERVICES_OPTION_VALUE);
            snapshot = currentSet;
          }
        } else {
          snapshot = currentSet;
        }

        applySelection(snapshot);
        controller.onChange?.(new Set(snapshot));
      });

      return controller;
    };

    const serviceSelectControllers = {
      build: createServiceSelectController(buildServicesSelect, { includeAllOption: true, defaultToAll: true }),
      start: createServiceSelectController(startServicesSelect, { includeAllOption: true }),
      registry: createServiceSelectController(registryServicesSelect, { includeAllOption: true }),
      clean: createServiceSelectController(cleanServicesSelect, { includeAllOption: true })
    };

    if (serviceSelectControllers.start) {
      serviceSelectControllers.start.onChange = (selection) => {
        updateStartDockerSocketVisibility(selection);
      };
    }

    if (startDockerSocketCheckbox) {
      startDockerSocketCheckbox.addEventListener('change', () => {
        startDockerSocketCheckboxTouched = true;
      });
    }

    if (settingsHostSocketInput) {
      settingsHostSocketInput.addEventListener('input', () => {
        const snapshot = serviceSelectControllers.start?.snapshot ?? new Set();
        updateStartDockerSocketVisibility(snapshot);
      });
    }

    const updateServiceSelectOptions = (serviceNames = []) => {
      for (const controller of Object.values(serviceSelectControllers)) {
        controller?.populate(serviceNames);
      }
      const snapshot = serviceSelectControllers.start?.snapshot ?? new Set();
      updateStartDockerSocketVisibility(snapshot);
    };

    const readServiceSelection = (controller) => {
      if (!controller) return [];
      return controller.read();
    };

    const applyServicesSelectionToPayload = (payload, selection) => {
      if (!payload) return;
      if (selection === ALL_SERVICES_OPTION_VALUE) {
        payload.services = 'all';
        return;
      }
      if (Array.isArray(selection) && selection.length) {
        payload.services = selection;
      }
    };

    const hasWardenSelection = (selection) => {
      if (selection === ALL_SERVICES_OPTION_VALUE) {
        return true;
      }
      return Array.isArray(selection) && selection.includes('warden');
    };

    const formatJSON = (value) => {
      try {
        return JSON.stringify(value, null, 2);
      } catch (error) {
        return String(value);
      }
    };

    const formatTable = (rows = [], columns) => {
      if (!Array.isArray(rows) || rows.length === 0) {
        return '—';
      }
      const resolvedColumns = Array.isArray(columns) && columns.length
        ? columns
        : Array.from(new Set(rows.flatMap((row) => Object.keys(row || {}))));
      const normalized = rows.map((row) => {
        const source = row && typeof row === 'object' ? row : {};
        return resolvedColumns.map((column) => String(source[column] ?? ''));
      });
      const widths = resolvedColumns.map((column, columnIndex) => {
        return Math.max(
          column.length,
          ...normalized.map((row) => row[columnIndex].length)
        );
      });
      const header = resolvedColumns
        .map((column, index) => column.padEnd(widths[index]))
        .join('  ');
      const separator = widths.map((width) => '─'.repeat(width)).join('  ');
      const body = normalized
        .map((row) => row.map((value, index) => value.padEnd(widths[index])).join('  '))
        .join('\n');
      return `${header}\n${separator}\n${body}`;
    };

    const formatProgressEvent = (event = {}) => {
      const { type, service, step, status, message } = event;
      const parts = [];
      if (type) parts.push(type);
      if (service) parts.push(`service: ${service}`);
      if (step) parts.push(`step: ${step}`);
      if (status) parts.push(`status: ${status}`);
      if (message) parts.push(message);
      if (parts.length === 0) {
        return JSON.stringify(event);
      }
      return parts.join(' • ');
    };

    const appendStreamLine = (payload = {}) => {
      const entry = document.createElement('div');
      entry.classList.add('log-entry');
      const context = document.createElement('span');
      context.classList.add('log-context');
      context.textContent = `[${payload.action ?? 'event'}]`;
      entry.appendChild(context);

      const messageNode = document.createElement(payload.type === 'table' ? 'pre' : 'span');
      messageNode.classList.add('log-message');

      if (payload.type === 'log') {
        const level = payload.level || 'info';
        const levelClass =
          level === 'success'
            ? 'status-ok'
            : ['warn', 'error', 'info'].includes(level)
              ? `status-${level}`
              : 'status-info';
        entry.classList.add(levelClass);
        messageNode.textContent = payload.message ?? '';
      } else if (payload.type === 'error') {
        entry.classList.add('status-error');
        messageNode.textContent = payload.message ?? JSON.stringify(payload);
      } else if (payload.type === 'container-log') {
        const { service, line } = payload.event || {};
        messageNode.textContent = service ? `${service}: ${line ?? ''}` : line ?? '';
      } else if (payload.type === 'progress') {
        messageNode.textContent = formatProgressEvent(payload.event);
      } else if (payload.type === 'table') {
        messageNode.textContent = formatTable(payload.data, payload.columns);
      } else if (typeof payload.message === 'string') {
        messageNode.textContent = payload.message;
      } else {
        messageNode.textContent = JSON.stringify(payload);
      }

      entry.appendChild(messageNode);

      if (streamOutput.children.length >= LOG_LIMIT) {
        streamOutput.removeChild(streamOutput.firstChild);
      }

      streamOutput.appendChild(entry);
      streamOutput.scrollTop = streamOutput.scrollHeight;
    };

    const clearStream = (label) => {
      streamOutput.textContent = '';
      appendStreamLine({ action: label, type: 'start', message: 'Request dispatched' });
    };

    const extractServiceNames = (services) => {
      if (!Array.isArray(services)) return [];
      const seen = new Set();
      const names = [];
      for (const service of services) {
        const candidate =
          typeof service === 'string'
            ? service
            : typeof service?.name === 'string'
              ? service.name
              : typeof service?.id === 'string'
                ? service.id
                : undefined;
        if (!candidate) continue;
        const normalized = candidate.trim();
        if (!normalized || seen.has(normalized)) continue;
        seen.add(normalized);
        names.push(normalized);
      }
      return names;
    };

    const fetchServicesOptions = async () => {
      try {
        const response = await fetch(SERVICES_ENDPOINT);
        if (!response.ok && response.status !== 207) {
          return;
        }
        const payload = await response.json();
        updateServiceSelectOptions(extractServiceNames(payload?.services));
      } catch (error) {
        console.warn('Failed to load services for selection controls', error);
      }
    };

    const readBuildServicesSelection = () => readServiceSelection(serviceSelectControllers.build);

    const safeParseJSON = (value) => {
      if (!value.trim()) return null;
      try {
        return JSON.parse(value);
      } catch (error) {
        throw new Error('Invalid JSON payload: ' + error.message);
      }
    };

    const readNDJSON = async (response, action) => {
      const reader = response.body?.getReader();
      if (!reader) {
        appendStreamLine({ action, type: 'error', message: 'Streaming unsupported in this browser.' });
        return;
      }

      const decoder = new TextDecoder();
      let buffer = '';
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop();
        for (const line of lines) {
          if (!line.trim()) continue;
          try {
            const payload = JSON.parse(line);
            appendStreamLine(payload);
          } catch (error) {
            appendStreamLine({ action, type: 'error', message: 'Malformed stream payload', raw: line });
          }
        }
      }
      if (buffer.trim()) {
        try {
          appendStreamLine(JSON.parse(buffer));
        } catch (error) {
          appendStreamLine({ action, type: 'error', message: 'Malformed stream payload', raw: buffer });
        }
      }
    };

    const invokeStreamEndpoint = async (action, url, payload) => {
      clearStream(action);
      let response;
      try {
        response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload ?? {})
        });
      } catch (error) {
        appendStreamLine({ action, type: 'error', message: error.message });
        return;
      }
      if (!response.ok && response.status !== 207) {
        appendStreamLine({ action, type: 'error', message: `Request failed: ${response.status}` });
        return;
      }
      await readNDJSON(response, action);
    };

    const actions = {
      'list-services': async () => {
        let response;
        try {
          response = await fetch(SERVICES_ENDPOINT);
        } catch (error) {
          servicesOutput.textContent = `Failed to load services (${error.message})`;
          return;
        }
        if (!response.ok && response.status !== 207) {
          servicesOutput.textContent = `Failed to load services (${response.status})`;
          return;
        }
        const payload = await response.json();
        updateServiceSelectOptions(extractServiceNames(payload?.services));
        const statusLabel = payload.ok ? 'status-ok' : 'status-warn';
        servicesOutput.innerHTML = '';
        const statusNode = document.createElement('span');
        statusNode.className = statusLabel;
        statusNode.textContent = payload.ok ? 'Healthy' : 'Partial';
        servicesOutput.appendChild(statusNode);
        servicesOutput.appendChild(document.createTextNode(`\n${formatJSON(payload)}`));
      },
      'load-settings': async () => {
        const response = await fetch('/api/settings');
        if (!response.ok) {
          settingsOutput.textContent = `Failed to load settings (${response.status})`;
          return;
        }
        const payload = await response.json();
        settingsOutput.textContent = formatJSON(payload);
        document.getElementById('settings-json').value = JSON.stringify(payload, null, 2);
        if (settingsHostSocketInput) {
          const value = Object.prototype.hasOwnProperty.call(payload || {}, 'hostDockerSocketOverride')
            ? payload.hostDockerSocketOverride
            : '';
          settingsHostSocketInput.value = value ?? '';
          const snapshot = serviceSelectControllers.start?.snapshot ?? new Set();
          updateStartDockerSocketVisibility(snapshot);
        }
      },
      build: async () => {
        const servicesSelection = readBuildServicesSelection();
        const concurrency = document.getElementById('build-concurrency').value;
        const payload = {
          useNoCache: document.getElementById('build-nocache').checked
        };
        applyServicesSelectionToPayload(payload, servicesSelection);
        if (concurrency.trim()) {
          payload.concurrency = safeParseJSON(concurrency);
        }
        await invokeStreamEndpoint('build', '/api/build', payload);
      },
      push: async () => {
        const servicesSelection = readServiceSelection(serviceSelectControllers.registry);
        const payload = {};
        applyServicesSelectionToPayload(payload, servicesSelection);
        await invokeStreamEndpoint('push', '/api/push', payload);
      },
      pull: async () => {
        const servicesSelection = readServiceSelection(serviceSelectControllers.registry);
        const payload = {};
        applyServicesSelectionToPayload(payload, servicesSelection);
        await invokeStreamEndpoint('pull', '/api/pull', payload);
      },
      start: async () => {
        const servicesSelection = readServiceSelection(serviceSelectControllers.start);
        const payload = {
          debugLevel: document.getElementById('start-debug').value || undefined,
          bootMode: document.getElementById('start-boot').value || undefined
        };
        applyServicesSelectionToPayload(payload, servicesSelection);

        if (
          hasWardenSelection(servicesSelection) &&
          startDockerSocketCheckbox &&
          !startDockerSocketCheckbox.disabled &&
          startDockerSocketCheckbox.checked
        ) {
          const overrideValue = settingsHostSocketInput?.value?.trim?.() ?? '';
          if (overrideValue) {
            payload.hostDockerSocketOverride = overrideValue;
          } else if (settingsHostSocketInput) {
            payload.hostDockerSocketOverride = null;
          }
        }

        await invokeStreamEndpoint('start', '/api/start', payload);
      },
      stop: async () => {
        await invokeStreamEndpoint('stop', '/api/stop');
      },
      clean: async () => {
        const servicesSelection = readServiceSelection(serviceSelectControllers.clean);
        const payload = {};
        applyServicesSelectionToPayload(payload, servicesSelection);
        await invokeStreamEndpoint('clean', '/api/clean', payload);
      },
      delete: async () => {
        const confirmDelete = document.getElementById('delete-confirm').checked;
        if (!confirmDelete) {
          alert('Please enable the confirmation checkbox before deleting resources.');
          return;
        }
        await invokeStreamEndpoint('delete', '/api/delete', { confirm: true });
      },
      'update-settings': async () => {
        try {
          const parsedPayload = safeParseJSON(document.getElementById('settings-json').value || '{}');
          const payload = (parsedPayload && typeof parsedPayload === 'object') ? parsedPayload : {};
          if (payload && typeof payload === 'object' && payload.defaults && Object.prototype.hasOwnProperty.call(payload.defaults, 'hostDockerSocketOverride')) {
            delete payload.defaults.hostDockerSocketOverride;
          }
          if (settingsHostSocketInput) {
            const overrideValue = settingsHostSocketInput.value.trim();
            payload.hostDockerSocketOverride = overrideValue ? overrideValue : null;
          }
          const response = await fetch('/api/settings', {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload || {})
          });
          if (!response.ok) {
            settingsOutput.textContent = `Failed to update settings (${response.status})`;
            return;
          }
          const body = await response.json();
          settingsOutput.textContent = formatJSON(body);
          if (settingsHostSocketInput) {
            const value = Object.prototype.hasOwnProperty.call(body || {}, 'hostDockerSocketOverride')
              ? body.hostDockerSocketOverride
              : '';
            settingsHostSocketInput.value = value ?? '';
            const snapshot = serviceSelectControllers.start?.snapshot ?? new Set();
            updateStartDockerSocketVisibility(snapshot);
          }
          document.getElementById('settings-json').value = JSON.stringify(body, null, 2);
        } catch (error) {
          settingsOutput.textContent = error.message;
        }
      }
    };

    document.body.addEventListener('click', async (event) => {
      const action = event.target?.dataset?.action;
      if (!action || !actions[action]) return;
      event.preventDefault();
      try {
        await actions[action]();
      } catch (error) {
        appendStreamLine({ action, type: 'error', message: error.message });
      }
    });

    updateServiceSelectOptions();
    fetchServicesOptions();
  </script>
</body>
</html>
